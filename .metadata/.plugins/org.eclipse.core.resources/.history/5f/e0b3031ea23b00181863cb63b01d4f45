package net.qhhhq.service.http.qcloud;

import java.util.Map;
import java.util.UUID;

import org.apache.log4j.Logger;
import org.json.JSONObject;
import org.springframework.stereotype.Component;

import com.qcloud.weapp.Hash;

import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http.HttpVersion;
import io.netty.handler.codec.http.HttpHeaders.Names;
import io.netty.handler.codec.http.HttpHeaders.Values;
import io.netty.handler.codec.http.websocketx.WebSocketFrameDecoder;
import io.netty.handler.codec.http.websocketx.WebSocketFrameEncoder;
import io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;
import io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;
import io.netty.handler.codec.http.websocketx.WebSocketVersion;
import net.qhhhq.service.common.HandlerChain;
import net.qhhhq.service.common.HttpRequestHandler;

@Component
public class TunnelConnectionServiceBean implements HttpRequestHandler {

	private static Logger log = Logger.getLogger(TunnelConnectionServiceBean.class);
	private WebSocketServerHandshaker handshaker;
	private ChannelHandlerContext ctx = null;
	private FullHttpRequest fhr = null;

	public void handle(Map<String, Object> paramMap, HandlerChain paramHandlerChain, JSONObject data) {
		ctx = (ChannelHandlerContext) paramMap.get("ctx");
		fhr = (FullHttpRequest) paramMap.get("fhr");
		String uri = fhr.uri();
		log.info("TunnelConnectionServiceBean start ......"+ uri);
		if(fhr != null && uri != null && uri.equals("/get/wsurl")) {
			String reqData = (String) paramMap.get("DATA");
			JSONObject reqJson = new JSONObject(reqData);
			String tcKey = reqJson.getString("tcKey");
			String signature = reqJson.getString("signature");
			String tcId = reqJson.getString("tcId");
			String dataJson = reqJson.getString("data");
			log.info(signature(dataJson, tcKey)+"==="+signature);
			if(signature(dataJson, tcKey).equals(signature)) {
				log.info(reqData);
				String tunnelId = UUID.randomUUID().toString().replaceAll("-", "");
				String connectUrl = "wss://10.255.105.225:443";
				fhr.headers().set("Upgrade", "websocket");
				fhr.headers().set("Sec-WebSocket-Version", "13");
				fhr.headers().set("Connection", "Upgrade");
				fhr.headers().set("Sec-WebSocket-Key", "x3JJHMbDL1EzLkh9GBhXDw==");
				handleHttpRequest(ctx, fhr);
				JSONObject json = new JSONObject();
				json.put("tunnelId", tunnelId);
				json.put("connectUrl", connectUrl);
				data.put("data", json.toString());
				data.put("code", 0);
			}
		}
		paramHandlerChain.doHandler(paramMap);
	}
    private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest request) {
        // 如果HTTP解码失败，返回HHTP异常
       /* if (!request.getDecoderResult().isSuccess() || (!"websocket".equals(request.headers().get("Upgrade")))) {
            sendHttpResponse(ctx, request, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST));
            return;
        }  */

        // 正常WebSocket的Http连接请求，构造握手响应返回
        WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory("wss://10.255.105.225:443", null, false);
        handshaker = wsFactory.newHandshaker(request);
        if (handshaker == null) { // 无法处理的websocket版本
            WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());
        } else { // 向客户端发送websocket握手,完成握手
        	log.info(ctx.channel());
        	log.info(request);
            handshaker.handshake(ctx.channel(), null);
            // 记录管道处理上下文，便于服务器推送数据到客户端
        }
    }

	private String signature(String data, String key) {
		return Hash.sha1(data + key);
	}

}
